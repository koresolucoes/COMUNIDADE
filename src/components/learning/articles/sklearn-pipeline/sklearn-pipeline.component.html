
<div class="max-w-4xl mx-auto">
  <header class="mb-12">
    <div class="text-sm text-gray-400 mb-3 flex items-center gap-2">
      <a routerLink="/learning" class="hover:text-blue-accent hover:underline">Trilhas de Aprendizagem</a>
      <span class="material-icons-outlined text-base">chevron_right</span>
      <a routerLink="/learning/python-machine-learning-sklearn" class="hover:text-blue-accent hover:underline">Introdução ao Machine Learning com Scikit-learn</a>
    </div>
    <h1 class="text-4xl md:text-5xl font-bold text-white tracking-tight">Construindo um Pipeline Completo</h1>
    <p class="mt-4 text-lg text-gray-400">Junte todos os passos, desde a leitura dos dados até a previsão final, em um pipeline reutilizável e organizado.</p>
  </header>
  <article class="prose-container space-y-12">
    <div class="p-6 bg-gray-900 border border-gray-800 rounded-lg">
      <h2 class="text-2xl font-semibold text-white !mt-0">O Problema: Vazamento de Dados e Código Repetitivo</h2>
      <p>
        Até agora, nós aplicamos o pré-processamento (como o `StandardScaler`) em todo o conjunto de dados antes de dividi-lo em treino e teste. Isso introduz um erro sutil, mas perigoso, chamado <strong>vazamento de dados (data leakage)</strong>. O scaler "aprende" a média de todo o conjunto, incluindo os dados de teste que o modelo não deveria ver. Isso pode fazer com que a performance do seu modelo pareça melhor do que realmente é.
      </p>
      <p>
        A forma correta é: "aprender" os parâmetros de pré-processamento <strong>apenas</strong> com os dados de treino e depois aplicar essa mesma transformação aos dados de teste. Fazer isso manualmente é repetitivo e propenso a erros.
      </p>
    </div>

    <div>
      <h2 class="text-2xl font-semibold text-white">A Solução: O `Pipeline` e o `ColumnTransformer`</h2>
      <p>
        O Scikit-learn oferece duas ferramentas incríveis para automatizar e organizar esse fluxo:
      </p>
      <ul class="list-disc list-inside text-gray-400 space-y-2">
        <li><strong>`ColumnTransformer`</strong>: Permite aplicar diferentes transformações a diferentes colunas. Por exemplo, aplicar `StandardScaler` em colunas numéricas e `OneHotEncoder` em colunas de texto.</li>
        <li><strong>`Pipeline`</strong>: Encadeia múltiplos passos de processamento e um modelo final em um único objeto. Ele garante que os dados passem por cada etapa na ordem correta, tanto no treino quanto na previsão.</li>
      </ul>
    </div>
    
    <!-- Visual Diagram -->
    <section>
       <h2 class="text-2xl font-semibold text-white mb-4">Anatomia de um Pipeline</h2>
       <div class="p-6 bg-gray-900 border border-gray-800 rounded-xl text-center">
          <div class="flex flex-col items-center">
            
            <div class="p-3 bg-gray-800 rounded-lg border border-gray-700 font-mono text-sm text-white shadow-lg">Dados Brutos (X_train, y_train)</div>
            <div class="h-8 w-px bg-gray-700"></div>

            <div class="p-3 bg-purple-900/30 border-2 border-purple-500/50 rounded-lg">
              <span class="text-xs text-purple-400 font-bold uppercase">Pipeline.fit()</span>
            </div>

            <div class="h-8 w-px bg-gray-700"></div>
            
            <div class="w-full p-4 bg-gray-800 rounded-lg border border-gray-700 flex justify-around">
                <!-- Numerical Branch -->
                <div class="flex flex-col items-center gap-2">
                    <div class="text-xs text-gray-400">Colunas Numéricas</div>
                    <div class="h-4 w-px bg-gray-600"></div>
                    <div class="p-2 bg-blue-900/50 rounded text-blue-300 text-xs border border-blue-700/50">StandardScaler</div>
                </div>
                <!-- Categorical Branch -->
                <div class="flex flex-col items-center gap-2">
                    <div class="text-xs text-gray-400">Colunas Categóricas</div>
                    <div class="h-4 w-px bg-gray-600"></div>
                    <div class="p-2 bg-green-900/50 rounded text-green-300 text-xs border border-green-700/50">OneHotEncoder</div>
                </div>
            </div>

            <div class="h-8 relative">
              <div class="absolute top-0 left-1/4 h-full w-px bg-gray-700"></div>
              <div class="absolute top-0 right-1/4 h-full w-px bg-gray-700"></div>
            </div>

            <div class="p-3 bg-yellow-900/30 border-2 border-yellow-500/50 rounded-lg">
              <span class="text-xs text-yellow-400 font-bold uppercase">LinearRegression</span>
            </div>
          </div>
       </div>
    </section>

    <!-- Code Lab -->
    <section>
      <h2 class="text-2xl font-semibold text-white mb-4">Construindo o Pipeline no Código</h2>
      <p class="text-gray-300 mb-6">
        Vamos aplicar este conceito a um conjunto de dados de exemplo. O código abaixo executa todo o processo: define os pré-processadores, monta o pipeline, treina com um único <code>.fit()</code> e avalia o resultado.
      </p>
      <app-python-console [initialCode]="pipelineCode" outputHeight="400px"></app-python-console>
    </section>
    
    <div class="p-6 bg-green-900/30 border border-green-700/50 text-green-300 rounded-lg">
      <h3 class="font-semibold text-green-200 text-lg mb-2">Por que Isso é Tão Poderoso?</h3>
      <p>
        O Pipeline cuida de tudo para você: ele aplica <code>fit_transform</code> nos dados de treino e apenas <code>transform</code> nos dados de teste, evitando o vazamento de dados. Seu código fica mais limpo, menos propenso a erros e muito mais profissional. Usar Pipelines é a prática padrão para qualquer projeto sério de Machine Learning com Scikit-learn.
      </p>
    </div>

    <div class="pt-8 text-center">
       <a routerLink="/learning/python-machine-learning-sklearn" class="inline-flex items-center gap-2 px-6 py-3 bg-gray-700 text-white rounded-md font-semibold hover:bg-gray-600 transition-colors">
        <span class="material-icons-outlined">arrow_back</span>
        Voltar para a Trilha
      </a>
    </div>
  </article>
</div>
